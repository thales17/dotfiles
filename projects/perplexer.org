#+title: projects/perplexer
#+exclude_tags: noexport
<2022-02-08 Tue>
* What is "Perplexer"?
- This is a simple text adventure game that I made
- It involves collecting a few keys to exit a maze
- I was inspired by [[https://www.youtube.com/watch?v=OXNLWy7rwH4][Infocom: The Documentary]]
- I originally wrote the game in [[*C Version][C]]
- This project is remaking that C version in Lisp
- Reading through the chapter on the text adventure game in Land of Lisp made me want to rewrite it in lisp
* Project Goals
- I wanted to compare using Common Lisp to implement a project I had first written in C
- A text adventure game also seems like a good chance to try more literate programming with Emacs org mode
  - Because of this the html export of this doc does not contain the full picture of how this is put together
  - To see all the parts you should look at the org mode source file
- While the game design is not the most extensible, the script and the game should be separated
- The core program of the game should be able to handle any script so long as it is structured to match the needed data
* Room Layout
- This graph visualizes the connections between the rooms in the game
- It doesn't spoil where the keys are though
#+begin_src dot :cmd dot :file perplexer_graph.png :exports results
  digraph {
      node      [shape=record];
      nw        [label = "shredded paper pile room"];
      w         [label = "mist room"];
      sw        [label = "green cracked room"];
      c         [label = "central room"];
      s         [label = "flame access"];
      n         [label = "printer room"];
      e         [label = "zigzag hallway"];
      se        [label = "perplexer room"];
      ne        [label = "tree room"];
      exit      [label = "end"];

      nw -> w;
      w -> nw;
      w -> sw;
      w -> c;
      sw -> w;
      c -> w;
      c -> s;
      c -> n;
      c -> e;
      n -> c;
      s -> c;
      e -> ne;
      e -> se;
      e -> c;
      ne -> e;
      se -> e;
      se -> exit;
  }
#+end_src

#+RESULTS:
[[file:perplexer_graph.png]]

* Game Script                                                      :noexport:
:PROPERTIES:
:header-args: :eval no
:END:
- This section has the text that is used in the game
** Welcome
*** Title
#+name: title
#+begin_src text
  Escape the perplexity\n---------------------\n
#+end_src

*** Help
#+name: help
#+begin_src text
  Use commands north, south, east, west to explore. The first time you enter a room you get a long description. After that, you will get a short description. Use the look command to read the long description again. Use the interact command to try to interact with the room. Use the quit command to exit the game. To see this message again type help.
#+end_src

** Northwest
*** Long Description
#+name: nw-desc
#+begin_src text
  You are underneath a light dangling from the ceiling by a string. North, west and east are blocked by walls. You see a pile of shredded up paper in the corner. You try to read it but are unable to piece it together. Through the east wall you hear the muffled sounds of a of a dot matrix printer. To the south you see a dark corridor and faintly hear running water.
#+end_src

*** Location Name
#+name: nw-location
#+begin_src text
shredded paper pile room
#+end_src
** North
*** Long Description
#+name: n-desc
#+begin_src text
  You see a walled in room with a table in the center. On the table is a dot matrix printer constantly printing the same 10 digit number over and over again.
#+end_src

*** Location Name
#+name: n-location
#+begin_src text
  printer room
#+end_src

*** Interaction
#+name: n-interact
#+begin_src text
  You rip the top page and stick it in your bag.
#+end_src

*** Unlock Description
#+name: n-unlock-desc
#+begin_src text
  You use your torch to burn a hole big enough to crawl through.
#+end_src

*** Locked Description
#+name: n-locked-desc
#+begin_src text
  You feel a wall different from the rest. Perhaps there is a way to destroy this obstacle.
#+end_src

** Northeast
*** Long Description
#+name: ne-desc
#+begin_src text
  You enter a bright room filled with mist. The walls are glass and you can see the sun is out. In the center of the room is an odd tree with giant leaves.
#+end_src

*** Location Name
#+name: ne-location
#+begin_src text
  tree room
#+end_src

*** Interaction
#+name: ne-interact
#+begin_src text
  You pull one of the leaves off the tree and place it in your bag.
#+end_src

** West
*** Long Description
#+name: w-desc
#+begin_src text
  The room is pitch black and it is hard to make anything out. You feel mist hitting your face from what sounds like a waterfall to the south. To the east you hear wind rustling and see a distant light.
#+end_src

*** Location Name
#+name: w-location
#+begin_src text
  mist room
#+end_src

** Center
*** Long Description
#+name: c-desc
#+begin_src text
  You are at a central room and can move in each direction. You hear a crackling sound to the south. To the north you hear the muffled sound of a dot matrix printer. The east is an unlit corridor. You can hear what sounds like someone murmuring to themselves.
#+end_src

*** Location Name
#+name: c-location
#+begin_src text
  central room
#+end_src

** East
*** Long Description
#+name: e-desc
#+begin_src text
  You crouch through a narrow doorway to enter a cramped hallway. The walls are painted with a black and white zigzag pattern. To the east you feel a cold wall, dead end. To the north you hear the sounds of birds chirping. The murmuring seems to be coming from the south. It sounds like they are answering questions to a quiz show but you can't hear any other voice.
#+end_src

*** Location Name
#+name: e-location
#+begin_src text
  zigzag hallway
#+end_src

** Southwest
*** Long Description
#+name: sw-desc
#+begin_src text
  The ground is broken and covered with cracks blasting the room with green light. You see a small red tablet with gold lettering on the floor. You are unable to make out the writing.
#+end_src
*** Location Name
#+name: sw-location
#+begin_src text
  green cracked room
#+end_src

*** Unlock Description
#+name: sw-unlock-desc
#+begin_src text
  Using the large leaf from your bag you hold it by the stem over your head. Jogging you are able to quickly enter the room.
#+end_src
*** Locked Description
#+name: sw-locked-desc
#+begin_src text
  You approach the falling water but despite being liquid it is far too cold to bear on your skin. You are unable to proceed.
#+end_src

*** Interaction
#+name: sw-interact
#+begin_src text
  You place the tablet in your bag.
#+end_src

** South
*** Long Description
#+name: s-desc
#+begin_src text
  You see a small rectangular hole in the south wall. On the other side all you can see are flames.
#+end_src
*** Location Name
#+name: s-location
#+begin_src text
  flame access
#+end_src
*** Interact
#+name: s-interact
#+begin_src text
  You pick up a branch from the floor and stick it in the hole. The branch is now a torch.
#+end_src

** Southeast
*** Long Description
#+name: se-desc
#+begin_src text
  Inside the room is a disheveled person pacing back and forth. You notice an earpiece in their ear and realize they are using that to communicate with someone. They seem to be trying to find the right words to please their captor to release them from the conversation. They do not notice you. Behind them you see an open window you could climb through and escape.
#+end_src

*** Location Name
#+name: se-location
#+begin_src text
  perplexer room
#+end_src

*** Unlock Description
#+name: se-unlock-desc
#+begin_src text
  You review the code from the dot matrix printer and put it in the combination lock. You hear a click and can now turn the door knob.
#+end_src

*** Locked Description
#+name: se-locked-desc
#+begin_src text
  The murmuring is definitely coming from behind the door. You twist the knob and it doesn't move. You see a 10 digit combination lock above door knob. You are unable to proceed without the code.
#+end_src

** Exit Room
*** Long Description
#+name: exit-desc
#+begin_src text
  Outside you are greeted by a group of lab coat wearing scientists. One scientists starts slow clapping and they all join in quickly afterwards. The hoist you up on their shoulders and start singing. You are not sure what is happening or where they are taking you.\n\n\nThe end
#+end_src

*** Location Name
#+name: exit-location
#+begin_src text
end
#+end_src

*** Unlock Description
#+name: exit-unlock-desc
#+begin_src text
  As you enter the room the gold letters on the red tablet begin to light up. You go to pull it out of your bag but it is hot to the touch so you drop it. The disheveled person stops in their tracks and walks towards the tablet. They seem utterly perplexed. While they are distracted you make a break for it and climb through the window.
#+end_src

*** Locked Description
#+name: exit-locked-desc
#+begin_src text
  Their pacing is preventing you from reaching the window.
#+end_src

** Deadend
#+name: deadend-desc
#+begin_src text
  A cold wall prevents you from moving in this direction
#+end_src

** No Interaction
#+name: no-interact-desc
#+begin_src text
  Nothing happened
#+end_src
* TODO Lisp Version

** Nodes

*** Descriptions
#+begin_src lisp :noweb yes
  (defparameter *nodes-descriptions* '((northwest
					("<<nw-desc>>"
					 nil
					 nil
					 nil))
				       (west
					("<<w-desc>>"
					 nil
					 nil
					 nil))
				       (southwest
					("<<sw-desc>>"
					 "<<sw-unlock-desc>>"
					 "<<sw-locked-desc>>"
					 "<<sw-interact>>"))
				       (north
					("<<n-desc>>"
					 "<<n-unlock-desc>>"
					 "<<n-locked-desc>>"
					 "<<n-interact>>"))
				       (central
					("<<c-desc>>"
					 nil
					 nil
					 nil))
				       (south
					("<<s-desc>>"
					 nil
					 nil
					 "<<s-interact>>"))
				       (northeast
					("<<ne-desc>>"
					 nil
					 nil
					 "<<ne-interact>>"))
				       (east
					("<<e-desc>>"
					 nil
					 nil
					 nil))
				       (southeast
					("<<se-desc>>"
					 "<<se-unlock-desc>>"
					 "<<se-locked-desc>>"
					 nil))
				       (exit
					("<<exit-desc>>"
					 "<<exit-unlock-desc>>"
					 "<<exit-locked-desc>>"
					 nil))))

#+end_src

#+RESULTS:
: *NODES-DESCRIPTIONS*

*** State

**** Visited

**** Locked / Unlocked

** Edges
#+begin_src lisp
  (defparameter *edges* '((northwest
			   (west south door))
			  (west
			   (northwest north door)
			   (southwest south door)
			   (central east door))
			  (southwest
			   (west north door))
			  (central
			   (north north door)
			   (east east door)
			   (south south door)
			   (west west door))
			  (north
			   (central south door))
			  (south
			   (central north door))
			  (east
			   (central west door)
			   (northeast north door)
			   (southeast south door))
			  (northeast
			   (east south door))
			  (southeast
			   (east north door)
			   (exit south door))))

#+end_src

#+RESULTS:
: *EDGES*

** Objects
#+begin_src lisp
  (defparameter *objects* '(torch umbrella passcode question))

  (defparameter *object-locations* '((torch south)
				     (umbrella northeast)
				     (passcode north)
				     (question southwest)))
#+end_src

#+RESULTS:
: *OBJECT-LOCATIONS*

* C Version
:PROPERTIES:
:header-args: :eval no
:END:
** Prompt
*** Prompting the User
- Interaction with the user happens through a custom prompt
- The prompt takes as arguments the prompt message, a validator function, pointer for the result of what the user typed, and a void pointer to some user data
- The prompt will continue to show the message and ask the user for input until the validator function returns a value other than zero
- The prompt function uses [[https://linux.die.net/man/3/fgets][fgets]] to read in no more than =PROMPT_MAX= number of characters
  - It then checks to see if the input string has a newline character in it, if not continue the loop and try again
- The user data argument gets passed into the validator function to allow the validator to use state from outside the prompt function
  - This was modeled after how the [[https://wiki.libsdl.org/SDL_UserEvent][user events]] work in SDL2
- Once the validator approves the input the result is returned
- This function is handy since it encapsulates the mechanics of getting input from the user
- The programmer only needs to worry about what is valid and what is not valid input
#+name: prompt-user
#+begin_src c
  void promptUser (const char *msg, int (*validator)(const char *, void *),
		   char *result, void *userData) {
    char input[PROMPT_MAX], *p;
    int isValid = 0;

    do {
      isValid = 0;
      printf("%s", msg);

      fgets(input, sizeof(input), stdin);
      if ((p = strchr(input, '\n')) == NULL) {
	continue;
      }

      *p = '\0';

      isValid = validator(input, userData);
    } while (isValid == 0);

    strcpy(result, input);
  }

#+end_src

*** Print Width
- This function is used to print a string with a max number of columns
- It checks to make sure the current word doesn't exceed the max before printing it on the current line
- This is handy for ensuring the presentation of the text looks good on very wide terminals
#+name: print-width
#+begin_src c
  void printWidth(const char *msg, int width) {
    int col = 0;
    for (int i = 0; i < DESC_MAX && msg[i] != '\0'; i++) {
      if (msg[i] == ' ') {
	int nextSpace = 1;
	while (i + nextSpace < DESC_MAX &&
	       msg[i + nextSpace] != ' ' &&
	       msg[i + nextSpace] != '\0') {
	  nextSpace++;
	}

	if (col + nextSpace > width) {
	  putchar('\n');
	  col = 0;
	} else {
	  putchar(' ');
	}
      } else {
	putchar(msg[i]);
	col++;
      }
    }

    putchar('\n');
  }
#+end_src

** Adventure
- The "engine" of the game is called adventure
*** Room Data Model
- The game is divided into a series of rooms
- Rooms can contain a variety of text:
  - =desc= - This is the main description of the room
  - =locationName= - This is a short description of the room
  - =unlockDesc= - This is what is displayed when the room is unlocked
  - =lockedDesc= - This is what is displayed when attempting to enter this room without the key
  - =interactDesc= - If the room has a key in it this text is displayed when the player uses the =interact= command
- The rooms can potentially contain or require keys
- Each room has a set of 4 pointers to other rooms in the cardinal directions
- If the direction pointer is null that indicates a dead end
#+name: room-data-model
#+begin_src c
  struct room {
    const char desc[DESC_MAX];
    const char locationName[30];
    const char unlockDesc[DESC_MAX];
    const char lockedDesc[DESC_MAX];
    const char interactDesc[DESC_MAX];
    int requiredKey;
    int containedKey;
    int unlocked;
    int visited;
    struct room *north;
    struct room *south;
    struct room *east;
    struct room *west;
  };

#+end_src

*** Move Input Validator
- The player is allow to only type a handful of commands into the prompt
- Since the prompt function allows custom validators, adventure provides one for playing a text adventure game
- This function loops through all the possible actions and their short commands
- If it is unable to find the input string in the valid strings it rejects the input
#+name: move-validator
#+begin_src c
  int isMoveValid (const char *move, void *userData) {
    static const char * const validInput[] = {
      "north", "n",
      "North", "N",
      "south", "s",
      "South", "S",
      "east", "e",
      "East", "E",
      "west", "w",
      "West", "W",
      "look", "l",
      "Look", "L",
      "bag", "b",
      "Bag", "B",
      "interact", "i",
      "Interact", "I",
      "help", "h",
      "Help", "H",
      "quit", "q",
      "Quit", "Q"
    };

    for (int i = 0; i < 36; i++) {
      if (strcmp(validInput[i], move) == 0) {
	return 1;
      }
    }

    return 0;
  }
#+end_src

*** Moving through rooms
- The move function will return the adjacent room based on the action (north, south, east or west)
- If the adjacent room in that direction is null then the original room is returned
#+name: move
#+begin_src c
  struct room * move (struct room *r, enum action a) {
    if (r == NULL) {
      return r;
    }

    struct room *next;

    switch (a) {
    case North:
      next = r->north;
      break;
    case South:
      next = r->south;
      break;
    case East:
      next = r->east;
      break;
    case West:
      next = r->west;
      break;
    default:
      return r;
    }

    if (next == NULL) {
      return r;
    }

    return next;
  }

#+end_src

*** Actions
- Actions are either moving around, looking, interacting with the room or looking in your bag
#+name: all-actions
#+begin_src c
  enum action {
    North,
    South,
    East,
    West,
    Look,
    Bag,
    Interact,
    Help,
    Quit
  };
#+end_src

*** Game Loop
- The loop of adventure is very similar to a REPL
**** Prompt the User for an Action
- The game uses the =>= character as the prompt
- The game supports upper or lower case for commands
- To streamline the conditional handling we convert any upper case letters to the lower case versions
- An easy way to do is is to add 32 to the character since all lower case letters are 32 away from their upper case
#+name: adventure-prompt
#+begin_src c
  promptUser("> ", isMoveValid, moveInput, NULL);
  char firstCh = moveInput[0];
  if (firstCh >= 'A' && firstCh <= 'Z') {
    firstCh += 32; // Make it lowercase
  }
#+end_src
**** Converting the Action String to Enum
- This uses the lowercase letter of the valid action the user typed with the =enum action=
#+name: adventure-action-convert
#+begin_src c
  enum action a;
  switch (firstCh) {
   case 'n':
     a = North;
     break;
   case 's':
     a = South;
     break;
   case 'e':
     a = East;
     break;
   case 'w':
     a = West;
     break;
   case 'l':
     a = Look;
     break;
   case 'b':
     a = Bag;
     break;
   case 'i':
     a = Interact;
     break;
   case 'h':
     a = Help;
     break;
   case 'q':
     a = Quit;
     break;
  }
#+end_src
**** Handling the Action
***** Look
- In the case of the look action all we need to do is print the description of the current room
#+name: adventure-handle-look
#+begin_src c
  printWidth(currentRoom->desc, DESC_WIDTH);
#+end_src

***** Move

****** Call the =move= function to get the next room
#+name: adventure-move-next
#+begin_src c
  nextRoom = move(currentRoom, a);
#+end_src

****** If the =nextRoom= is the same as the =currentRoom= it is a dead end
#+name: adventure-move-deadend
#+begin_src c
  if (nextRoom == currentRoom) {
    printWidth(deadEnd, DESC_WIDTH);
   }
#+end_src

****** If the room requires a key, is it in the bag?
- This iterates through the keys in tha bag
- If it finds the required key it sets the state of that room to unlocked
- It also prints the unlock description
- If the key is not in the bag it prints the locked description
#+name: adventure-move-required-key
#+begin_src c
  int moveOk = 0;
  if (nextRoom->requiredKey != 0) {
    for (int i = 0; i < bagLen; i++) {
      if (nextRoom->requiredKey == bag[i]) {
	if (nextRoom->unlocked == 0) {
	  printWidth(nextRoom->unlockDesc, DESC_WIDTH);
	}
	moveOk = 1;
	nextRoom->unlocked = 1;
	break;
      }
    }

    if (moveOk == 0) {
      printWidth(nextRoom->lockedDesc, DESC_WIDTH);
    }
   } else {
    moveOk = 1;
   }
#+end_src

****** Print the description when entering the new room
- If the room has been visited already we just display the location name
- If it is the first time visiting the room we want to show the full description
#+name: adventure-move-desc
#+begin_src c
  if (nextRoom->visited == 0) {
    printWidth(nextRoom->desc, DESC_WIDTH);
   } else {
    printWidth(nextRoom->locationName, DESC_WIDTH);
   }
#+end_src

****** Advance the =currentRoom= to the =nextRoom=
- Also ensure the room is marked as visited
#+name: adventure-move-advance
#+begin_src c
  currentRoom = nextRoom;
  currentRoom->visited = 1;
#+end_src

****** Deciding on whether or not to go to the next room
- Before entering a room this function checks to see if you have the needed key
- If you have never been to the room before it will display the long description, otherwise it will display the short
- Once the user has reached the exit room the game ends
****** Handle Move                                                 :noexport:
#+name: adventure-handle-move
#+begin_src c :noweb yes
  <<adventure-move-next>>

  <<adventure-move-deadend>> else {
      <<adventure-move-required-key>>
      if (moveOk) {
	<<adventure-move-desc>>
	<<adventure-move-advance>>
	<<adventure-move-autopickup>>
       }
    }
#+end_src

***** Inventory / Bag
#+name: adventure-handle-bag
#+begin_src c
  if (bagLen == 0) {
    printf("Your bag is empty\n");
  } else {
    printf("In your bag you find:\n");
    for (int i = 0; i < bagLen; i++) {
      if (bag[i] >= 0 && bag[i] < keyCount ) {
	printf("\t- %s\n", keyDesc[bag[i]]);
      } else {
	printf("\t- Error\n");
      }
    }
  }
#+end_src

***** Interact
- This will check if the room contains a key
- If it does it will print the interaction description
- The key will be added to the bag and the room contained key will be set to none
#+name: adventure-handle-interact
#+begin_src c :noweb yes
  if (currentRoom->containedKey != 0) {
    bag[bagLen] = currentRoom->containedKey;
    bagLen++;
    currentRoom->containedKey = 0;

    printWidth(currentRoom->interactDesc, DESC_WIDTH);
   } else {
    printWidth("<<no-interact-desc>>", DESC_WIDTH);
   }

#+end_src

***** Help
- When the user types the help command we just redisplay the help message
#+name: adventure-handle-help
#+begin_src c :noweb yes
  printWidth("<<help>>", DESC_WIDTH);
#+end_src

***** Quit
- To handle the quit action we just display a message and return from the =adventure= loop
#+name: adventure-handle-quit
#+begin_src c
  printf("Goodbye!\n");
  return;
#+end_src


**** Full Adventure Game Loop                                      :noexport:
#+name: adventure-loop
#+begin_src c :noweb yes
  void adventure (struct room *startRoom, struct room *exitRoom,
		  const char *deadEnd, int keyCount, const char **keyDesc) {
    struct room *currentRoom = startRoom;
    struct room *nextRoom = NULL;

    int bag[9] = { };
    int bagLen = 0;
    char moveInput[10] = { };

    printWidth(currentRoom->desc, DESC_WIDTH);
    currentRoom->visited = 1;
    do {
      <<adventure-prompt>>

      <<adventure-action-convert>>

      switch (a) {
      case Look:
	<<adventure-handle-look>>
	break;
      case Bag:
	<<adventure-handle-bag>>
	break;
      case Interact:
	<<adventure-handle-interact>>
	break;
      case Help:
	<<adventure-handle-help>>
	break;
      case Quit:
	<<adventure-handle-quit>>
	break;
      case North:
      case South:
      case East:
      case West:
	<<adventure-handle-move>>
	break;
      }
    } while(currentRoom != exitRoom);
  }
#+end_src

** Perplexer
- The perplexer game code mostly consists of setting up the room data structures
- A local enum is created for all the possible keys in the game
- If a room needs a key or contains a key the enum value is used
- A maze is built connecting the rooms together and the starting node is passed to the adventure function
- Utilizing org babel tangle and weave features are great for text based games
  - You can edit the descriptions in a dedicated text block, then weave that into the code blocks
#+name: perplexer-main
#+begin_src c :noweb yes
  int main (int argc, char **argv) {
    enum key { None, Torch, Umbrella, Passcode, Tablet };
    int keyCount = 5;
    const char *keyDesc[] = { "None", "Torch", "Umbrella", "Passcode", "Tablet" };

    struct room nw = {
      .desc = "<<nw-desc>>",
      .locationName = "<<nw-location>>",
      .unlockDesc = "",
      .lockedDesc = "",
      .interactDesc = "",
      .requiredKey = None,
      .containedKey = None
    };

    struct room n = {
      .desc = "<<n-desc>>",
      .locationName = "<<n-location>>",
      .unlockDesc = "<<n-unlock-desc>>",
      .lockedDesc = "<<n-locked-desc>>",
      .interactDesc = "<<n-interact>>",
      .requiredKey = Torch,
      .containedKey = Passcode
    };

    struct room ne = {
      .desc = "<<ne-desc>>",
      .locationName = "<<ne-location>>",
      .unlockDesc = "",
      .lockedDesc = "",
      .interactDesc = "<<ne-interact>>",
      .requiredKey = None,
      .containedKey = Umbrella
    };

    struct room w = {
      .desc = "<<w-desc>>",
      .locationName = "<<w-location>>",
      .unlockDesc = "",
      .lockedDesc = "",
      .interactDesc = "",
      .requiredKey = None,
      .containedKey = None
    };

    struct room c = {
      .desc = "<<c-desc>>",
      .locationName = "<<c-location>>",
      .unlockDesc = "",
      .lockedDesc = "",
      .interactDesc = "",
      .requiredKey = None,
      .containedKey = None
    };

    struct room e = {
      .desc = "<<e-desc>>",
      .locationName = "<<e-location>>",
      .unlockDesc = "",
      .lockedDesc = "",
      .interactDesc = "",
      .requiredKey = None,
      .containedKey = None
    };

    struct room sw = {
      .desc = "<<sw-desc>>",
      .locationName = "<<sw-location>>",
      .unlockDesc = "<<sw-unlock-desc>>",
      .lockedDesc = "<<sw-locked-desc>>",
      .interactDesc = "<<sw-interact>>",
      .requiredKey = Umbrella,
      .containedKey = Tablet
    };

    struct room s = {
      .desc = "<<s-desc>>",
      .locationName = "<<s-location>>",
      .unlockDesc = "",
      .lockedDesc = "",
      .interactDesc = "<<s-interact>>",
      .requiredKey = None,
      .containedKey = Torch
    };

    struct room se = {
      .desc = "<<se-desc>>",
      .locationName = "<<se-location>>",
      .unlockDesc = "<<se-unlock-desc>>",
      .lockedDesc = "<<se-locked-desc>>",
      .interactDesc = "",
      .requiredKey = Passcode,
      .containedKey = None
    };

    struct room exitRoom = {
      .desc = "<<exit-desc>>",
      .locationName = "<<exit-location>>",
      .unlockDesc = "<<exit-unlock-desc>>",
      .lockedDesc = "<<exit-locked-desc>>",
      .interactDesc = "",
      .requiredKey = Tablet,
      .containedKey = None
    };

    nw.south = &w;

    n.south = &c;

    ne.south = &e;

    w.north = &nw;
    w.south = &sw;
    w.east  = &c;

    c.north = &n;
    c.east = &e;
    c.south = &s;
    c.west = &w;

    e.north = &ne;
    e.south = &se;
    e.west = &c;

    sw.north = &w;

    s.north = &c;

    se.north = &e;
    se.south = &exitRoom;
    se.east = &exitRoom;

    printf("<<title>>");

    printf("\n\n\n");

    adventure(&nw, &exitRoom, "<<deadend-desc>>", keyCount, keyDesc);

    return 0;
  }

#+end_src

** Complete Code Listing
*** constants.h
#+begin_src c :tangle ~/tmp/perplexer/constants.h :mkdirp yes
  #ifndef _CONSTANTS_H_
  #define _CONSTANTS_H_

  #define PROMPT_MAX 50
  #define DESC_MAX 500

  #endif
#+end_src
*** prompt.h
#+begin_src c :tangle ~/tmp/perplexer/prompt.h :mkdirp yes
  #ifndef _PROMPT_H_
  #define _PROMPT_H_

  #include <stdint.h>

  #include "constants.h"

  void promptUser (const char *, int (*)(const char *, void *), char *, void *);
  int termSetEcho (int echo);
  void printWidth (const char *, int);

  #endif
#+end_src
*** prompt.c
#+begin_src c :tangle ~/tmp/perplexer/prompt.c :mkdirp yes :noweb yes
  #include <stdio.h>
  #include <string.h>
  #include <termios.h>
  #include <unistd.h>

  #include "prompt.h"

  <<prompt-user>>

  int termSetEcho (int echo) {
    struct termios termInfo;
    int r = tcgetattr(STDIN_FILENO, &termInfo);
    if (r > 0) {
      return r;
    }

    if (echo) {
      termInfo.c_lflag |= ECHO;
    } else {
      termInfo.c_lflag &= ~ECHO;
    }

    return tcsetattr(STDIN_FILENO, TCSANOW, &termInfo);
  }

  <<print-width>>

#+end_src
*** adventure.h
#+begin_src c :tangle ~/tmp/perplexer/adventure.h :mkdirp yes :noweb yes
  #ifndef _ADVENTURE_H_
  #define _ADVENTURE_H_

  #include "constants.h"

  <<room-data-model>>

  <<all-actions>>

  int isMoveValid (const char *, void *);
  struct room * move (struct room *, enum action);
  void adventure (struct room *, struct room *, const char *, int, const char **);

  #endif
#+end_src

*** adventure.c
#+begin_src c :tangle ~/tmp/perplexer/adventure.c :mkdirp yes :noweb yes
  #include <stdio.h>
  #include <string.h>

  #include "prompt.h"
  #include "adventure.h"

  #define DESC_WIDTH 55

  <<move-validator>>

  <<move>>

  <<adventure-loop>>
#+end_src
*** main.c
#+begin_src c :tangle ~/tmp/perplexer/main.c :mkdirp yes :noweb yes
  #include <stdio.h>

  #include "adventure.h"
  #include "prompt.h"

  <<perplexer-main>>
#+end_src
*** Build                                                          :noexport:
#+begin_src sh :eval yes
  #!/bin/sh

  # Exit on command failure
  set -e

  SRC="prompt.c adventure.c main.c"
  OUTPUT=perplexer

  rm -Rf ~/tmp/perplexer

  ../scripts/tangle.sh perplexer.org

  cd ~/tmp/perplexer

  gcc -o $OUTPUT $SRC -fstack-protector -Wall -Werror
#+end_src

#+RESULTS:

# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
