#+title: notes/lisp
<2022-03-19 Sat>
* Resources
- [[https://lispcookbook.github.io/cl-cookbook/][Common Lisp Cook Book]]
- [[http://www.lispworks.com/documentation/HyperSpec/Front/index.htm][Common Lisp Hyper Spec]]
* Source Files
- Common Lisp source files can have the =.lisp= extension
* Multi-Paradigm
- ANSI Common Lisp is multi paradigm
- It supports functional, generic, object oriented and domain specific programming styles.
* SLIME
- Common Lisp development environment for Emacs
- The official webpage is, https://common-lisp.net/project/slime/
- To use with org babel ensure that =lisp= is enabled in your =org-babel-load-langauges=
- Start slime =M-x slime= before attempting to evaluate a common lisp source block with =C-c C-c=
- You should be able to access variables and functions inside the SLIME REPL that are defined in the source code blocks
- Use =C-c C-d d= to view the documentation for the symbol at point
  - This might show you a link to http://www.ai.mit.edu to get the real documentation
* CLISP
- Easy to use and portable common lisp compiler that runs on most operating systems
- Also provides debugger and interpreter
* SBCL
- Steel Bank Common Lisp descends from Carnegie Mellon, Steel being Andrew Carnegie's industry and Banking being Andrew Mellon's industry
- Considered more heavy duty than CLISP
- Also provides debugger and interpreter
* Common Lisp Syntax
** Anonymous (Lambda) Functions
- This creates a lambda function that doubles the input =(lambda (x) (* 2 x))=
** Cons Pairs (Dotted Lists) vs Lists
- A list is really a chain of cons that ends with an empty list or nil
- For exmaple ='(1 2 3)= is =equal= to =(cons 1 (cons 2 (cons 3 nil))=
- Any cons cell that doesn't end in nil is known as a dotted list
- =(cons 1 2)= is displayed by the REPL as =(1 . 2)=
- You can create dotted lists with a quote as well, ='(1 . 2)=
- You can make a list using quote and dot, ='(1 . (2 . (3 . nil)))= is equal to ='(1 2 3)=
- =(cdr '(1 . 2))= is =2= not =(2)=
- =(cdr '(1 2))= is =(2)= not =2=
- Cons pairs are useful for x/y coordinates and key value pairs
** Circular Lists
- When using circular lists you should set the global =*print-circle*= to true, =(setf **print-circle** t)=
- The above enables complex printing features to be enabled when using self-referential lists
- Below is an example of creating a circular list
#+begin_src lisp
  (defparameter x '(1 2 3))
  (setf (cdddr x) x)
#+end_src
- You can use infinitely large index values in the above example
- For instance =(nth 1000 x)= would return =2=
** Literals
*** Char
- You can represent a character literal with a =#= followed by a backward slash and the character
- For example =#\a= is the representation of the character =a=
*** Newline
- =#\newline=
*** Tab
- =#\tab=
*** Space
- =#\space=
*** nil
- nil can be represented with =nil=, ='nil=, =()=, or ='()=
** Symbols
- Symbols in Common Lisp are case insensitive
- It is *common* to only use lowercase when writing common lisp source code
- To make a symbol that is case sensitive surround it with pipe, =|=, characters
  - This also allows you to use punctuation in a symbol name
  - =|Ca$e mATT3rz|= is an example
** Quoting
- Use the single quote ='= to quote a list
- To quasiquote use the backtick =`= and the comma to unquote =,=
- =`(one plus two is ,(+ 1 2))=
- The =#= before the quote is used to indicate the quoted symbol is a function
- Common Lisp is a *LISP-2* rather than a *LISP-1* like Scheme
  - This means it has *2* separate scope for functions and data
  - You can have a function and data with the same symbol name
  - The caveat is you must use the =#= when quoting a function
** Variables
*** Globals
- Use =defparameter= to create global variables
  - The =defparameter= function will mutate the value of a global if it already exists
- It is a common practice to surround global variables with earmuffs (asterisks)
- For example a global named num would look like this =*num*=
- Another option to create globals is =defvar=
  - If the variable already exists =defvar= will not change the existing value
*** Local variables
- Use =let= function to define local variables
*** Mutating
- Use =setf= to change the value of an existing variable
** Functions
*** Globals
- Use =defun= to define a global function
#+begin_src lisp
  (defun function_name (arguments)
    ...body)
#+end_src
*** Local Named Functions
- To define a local function use the =flet= form
- =flet= is very similar to =let= for variables but instead
#+begin_src lisp
  (flet ((function_name (arguments)
	   ...function body))
    ...body)
#+end_src
- If you want to reference other local functions in an =flet= you should use =labels= instead
- You can also =labels= to call a local named function recursively
#+begin_src lisp
  (labels ((function_a (n)
	     (+ n 2))
	   (function_b (n)
	     (function_a (function_a n))))
    (function_b 2))
#+end_src

#+RESULTS:
: 6
*** Argument Limits
- There is a limit on the number of arguments a function can have
- You can check those limits in the Common Lisp REPL with =call-arguments-limit=
** Eval
- You can evaluate a quoted symbol with =eval=
- =(eval '(+ 2 2))= should return =4=
- Like =eval= in JavaScript it can be a huge security risk in your program
** Loops
- Loops can be a good alternative to recursion, especially when using an implementation that does not have tail recursion support
- The most basic form of the =loop= is shown below
#+begin_src lisp
  (loop
    (sexp)
    (sexp)
    ...
    (when (predicate)
      (return)))
#+end_src
- The =return= command exits the loop
** Nullary Functions (Thunks)
- A nullary function is a function that has no arguments
- They are also commonly known as thunks or suspensions
* Common Lisp Functions
** Math
*** Incrementing
- You can use =1-= to decrement by 1, =(1- 10)= evaluates to 9
- You can also use =1+= to increment by 1, =(1+ 9)= evaluates to 10
*** Exponent
- Use =expt= to raise a number to an exponent, =(expt 53 53)= raises 53 to the 53rd power
*** Random numbers
- Use the =random= function to generate a random number
- It takes the limit as an argument which can be either an int or a float
- The returned number will be less than the limit
- If it is a float than the random number generated will also be a float
- This has the side effect of changing the internal =random-state=
*** Arithmetic Shift (bitwise shift)
- https://en.wikipedia.org/wiki/Arithmetic_shift
- Use the =ash= function which takes two arguments, the number and the amount of bits to shift left
- To shift right use a negative number
** Strings
*** Concatenate
- Use =concatenate= to join multiple strings together
- Use the symbol ='string= as the first argument to the function
- =(concatenate 'string "abc" "def")= should return ="abcdef"=
*** Converting to and from character lists
- Use =coerce= with either the =list= or =string= type
- =(coerce "ABC" 'list)= should return =(#\A #\B #\C)=
- =(coerce '(#\A #\B #\C) 'string)= should return ="ABC"=
- This can be used with =mapcar= to iterate over each character
#+begin_src lisp
(mapcar #'(lambda (c)
	    (princ (format nil "char: ~C~C" c #\newline)))
	(coerce "abc123" 'list))
#+end_src

#+RESULTS:
| char: a |
| char: b |
| char: c |
| char: 1 |
| char: 2 |
| char: 3 |

*** Converting symbols to strings
- Use =prin1-to-string= to convert symbols to strings
- =(prin1-to-string 'abc)= should return "ABC"
- The =write-to-string= function also can convert data to strings
*** Multi Line Strings
- Lisp will store the newline character in the string
- So the =\n= character is not needed for multi line strings
#+begin_src lisp
(setq mystring "the first line
the second line
and the third")
#+end_src
- To insert a newline into a string use the =format= function and the =~C= control character
- The =~C= control chacter means insert a character literal, you can use the =#\newline= character literal to get a new line
#+begin_src lisp
(format nil "hello~Cworld" #\newline)
#+end_src

** Lists
*** push
- Adds item to the beginning of a list
- The list must be a variable
#+begin_src lisp
  (defparameter *some-list* nil)

  (push 4 *some-list*)
  (push 3 *some-list*)
  (push 2 *some-list*)
  (push 1 *some-list*)
  ,*some-list*
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 |
*** last
- You can get the last element of a list with =last=
*** Using push to append
- Since a list is just a =cons= pairs, creating a new =cons= pair with the last element will append
- The =cdr= of the last element of a list is an empty list or =nil=
- If you =push= into that empty list you will append to the list
- For instance if =a= is =(1 2 3)= this should append 4 to the list =(push 4 (cdr (last a)))=
*** member
- Checks to see if an item is inside a list
- =(member 1 '(1 2 3 4))=
- This will return true when you check if =nil= is in the list
*** find
- Use find to search through a list for the first item that matches
- The search value is the first argument
- The second argument is the list that is being searched
- The keyword parameter passed with =:key= tells find how to determine if the list item matches the search
- =(find 20 '((a 5) (b 20) (c 6) (d 20)) :key #'cadr)= should return =(b 20)=
*** find-if
- Returns the first item in a list that satisifies the predicate
- =(find-if #'oddp '(2 4 5 6))=
- Returns nil if the item is not found
- This will not work when searching for =nil= in a list
*** mapcar
- Use =mapcar= to run a function on each element of a list
- =(mapcar #'(lambda (n) (1+ n)) '(1 2 3))= should return =(2 3 4)=
- You can also run =mapcar= over multiple sequences
- =(mapcar #'(lambda (m n) (list m n)) '(1 2 3) '(a b c))= should return =((1 a) (2 b) (3 c))=
- =mapc= is a more efficient version of mapcar that does not return the list
- =maplist= is another variant of =mapcar= that gives the remainder of the list as an argument to the function rather than a single item
*** apply
- Use =apply= to call a functions once with all the elements of a list as its arguments
*** remove-if-not
- Removes all items from the list that do not satisfy the predicate
- =(remove-if-not #'oddp '(1 2 3 4 5))= should return =(1 3 5)=
*** nth
- Use =nth= to get the value at index n from a list
- =(nth 2 '(7 8 9))= should return =9=
*** use setf and nth to change list item value
- You can use =setf= to mutate a list
- For example if you have a list named =l= with the value =(1 1 1)=
- =(setf (nth 2 l) 4)= should mutate =l= to be =(1 1 4)=
*** subseq
- Use =subseq= to get a sub sequence of a list
- The start index is required and you can optionally add the end index
- The start index is inclusive and the end index is exclusive, =(start end]=
- =(subseq '(9 8 7 6) 1 3)= should return =(8 7)=
*** Swapping list items with =rotatef=
- If you have the list =x= with the value =(1 2 3)=
- You can swap the 1 and with like so =(rotatef (nth 0 x) (nth 2 x))=
  - This should return =(3 2 1)=
- This will mutate the list
*** concatenate
- Use =concatenate= to join multiple lists together
- Use the symbol ='list= as the first argument to the function
- =(concatenate 'list '(1 2 3) '(4 5 6))= should return =(1 2 3 4 5 6)=
*** Slicing an item out of a list
- You can generate a new list with a particular index sliced out using =concatenate= and =subseq=
- If you have the list =d= with the value =(1 2 3 4 5)=
- =(concatenate 'list (subseq d 0 2) (subseq d 3))= should return =(1 2 4 5)=
*** Testing the values of a list with =every= =some= =notevery= =notany=
- These functions run a predicate and return a different boolean value based on their rules
- =every= returns nil at the first instance of a =nil= value, similar to logical and
- =some= returns true if any of the values return true
- =notany= returns nil if any of the values return true
- =notevery= returns true if all the values are false
- =(every #'identity '(t t nil)= should return nil
- =(every #'identity '(t t t))= should return true
*** substitute-if
- Replaces every item in a sequence with the first argument if it passes the second argument predicate
- For instance, =(substitute-if 0 #'oddp '(1 2 3 4 5))= will return =(0 2 0 4 0)=

*** Index of item in list
- The index of the first instance of an item in a list can be found with the =position= function
#+begin_src lisp
(position 2 '(1 2 3 4 2))
#+end_src
- The above code will return =1= since that is the index of the first 2 in the list
** Association Lists (alists)
- Use =assoc= to find the value of a key in an alist
#+begin_src lisp
  (assoc 'mykey '((somekey (some-value))
		  (mykey (my-value))
		  (otherkey (other-value))))
#+end_src
#+RESULTS:
| MYKEY | (MY-VALUE) |
- alists can have multiple instances of a key inside them
- When this happens =assoc= will return the first instance
- If you push new keys into the alist you can overwrite the value of a key while preserving the previous value
- You can use =setf= to change the value of an list, =(setf (cadr (assoc '2 alist)) t)=
- alists are not very efficient beyond a dozen items
** Logic / Conditionals
*** Complementing Predicates
- If you have a predicate and you want the opposite of it or complement you can use the higher order function =complement= to achieve that
- For example =(substitute-if 0 (complement #'oddp) '(1 2 3 4 5))= should return =(1 0 3 0 5)=
*** Shortcut Boolean Evaluation
- When evaluating an =or= or =and= boolean operator lisp will stop when it encounters the first symbol that evaluates to either true or false
- For example when evaluating an =or= the first true that is encountered causes lisp to stop
- When evaluating an =and= the first false encounted causes lisp to stop
- This allows you to build conditionals out of =or= or =and= statements
**** and
#+begin_src lisp
  (defun pred_a ()
    t)

  (defun pred_b ()
    t)

  (defun work ()
    'work-when)

  (when (pred_a)
      (when (pred_b)
	  (work)))
#+end_src

#+RESULTS:
: WORK-WHEN
#+begin_src lisp
  (defun pred_a ()
    t)

  (defun pred_b ()
    t)

  (defun work ()
    'work-and)

  (and (pred_a) (pred_b) (work))
#+end_src

#+RESULTS:
: WORK-AND

**** or
#+begin_src lisp
  (defun pred_a ()
    nil)

  (defun pred_b ()
    nil)

  (defun work ()
    'work-unless)

  (unless (pred_a)
    (unless (pred_b)
      (work)))
#+end_src

#+RESULTS:
: WORK-UNLESS

#+begin_src lisp
  (defun pred_a ()
    nil)

  (defun pred_b ()
    nil)

  (defun work ()
    'work-or)

  (or (pred_a) (pred_b) (work))
#+end_src

#+RESULTS:
: WORK-OR
** Equality
- Use =eq= for comparing symbols
  - =eq= returns true when two symbols point to the same =cons=
  - =eql= will also return true when characters and numbers are used instead of symbols
- Use =equal= for comparing everything else
  - =equal= will tell you if two things are isomorphic (look the same)
  - =equalp= will return true when strings have different capitalization, or numbers are not the same type (floats vs ints)
- The === comparison is meant primarily for numbers
- =string-equal= is specific for strings
- =char-equal= is specific for chars
** I/O
*** Printing and Reading
- Use =print= to display a string on stdout
  - This will automatically add a new line at the end of the string
  - =prin1= and =princ= will not add the =newline=
  - =print= will print values as they are stored in Lisp, so strings will have quotes and literals are displayed as such
    - =(print #\newline)= will actually print =#\newline= to stdout
  - Use =princ= to not add the quotation marks and use the characters the literals represent
    - =(princ #\newline)= will just print an empty line
  - The goal of =print= is to output data in a way that it could be re-read back into its internal representation
- Use =read= to read from stdin
  - This function is called with no arguments and returns after the user has typed something and pressed enter
  - You can use this to assign the value into a variable: =(let ((user-input (read))))=
- Both =print= and =read= can handle any Lisp data type, including symbols
- Use =read-line= to read the input as a string only rather than any valid Lisp data
- Use the function =fresh-line= to print a new line: =(fresh-line)=
*** Files
- =with-open-file= optionally accepts a steam and file name to open a file
- If you do not pass in an existing stream a new one is created
- With the stream variable print functions can send their output to that file
- If the stream is =*standard-output*= then the print functions will automatically send the output to the file
#+begin_src lisp
  (with-open-file (stream
		   "~/tmp/testfile.txt"
		   :direction :output
		   :if-exists :supersede)
    (princ "Hello World!" stream)
    (princ #\newline stream))
#+end_src

#+RESULTS:
: #\Newline
- There is a global stream =*standard-ouput*= that represents stdout of the lisp environment
* Quick Lisp
- [[https://www.quicklisp.org/beta/][Quicklisp]] is a library manager (package manager) for Common Lisp
** Installation
- Download =quicklisp.lisp= form their website, =curl -O https://beta.quicklisp.org/quicklisp.lisp=
- Download the PGP signature from their website, =curl -O https://beta.quicklisp.org/quicklisp.lisp.asc=
- Download the release signing public key, =curl -O https://beta.quicklisp.org/release-key.txt=
- Import the release signing key, =gpg --import release-key.txt=
- Verify the =quicklisp.lisp= file, =gpg --verify quicklisp.lisp.asc quicklisp.lisp=
- Start up a Common Lisp environment
- Inside the REPL run, =(load "quicklisp.lisp")= (Ensure the REPL was started in the same folder Quicklisp was downloaded to)
- Run =(quicklisp-quickstart:install)= to install Quicklisp
- This will create a =quicklisp= folder in your home directory
- Normally when starting a new lisp session you would run =(load "~/quicklisp/setup.lisp)= to load Quicklisp into the running session
- Use =(ql:add-to-init-file)= to have this happen automatically
- Install the =slime helper=, =(ql:quickload "quicklisp-slime-helper")=
  - Be sure to follow the instructions
** Installing Libraries
- This is an example of installing a package, =(ql:quickload "vecto")=
- This is an example of uninstalling a package, =(ql:uninstall "vecto")=
- To search for a library to install use apropos, =(ql:system-apropos "sdl2")=
** Upgrading Quicklisp
- Use =(ql:update-dist "quicklisp")= to update Quicklisp
- Run =(ql:update-client)= to update the client
** SDL2
- [[https://github.com/lispgames/cl-sdl2][Github: cl-sdl2]]
  - I was unable to get =defpackage-plus= to work in =clisp=, it does work with =sbcl=
- Go into =~/quicklisp/local-projects= folder
  - Clone =git clone https://github.com/rpav/cl-autowrap.git=
  - Clone =git clone https://github.com/lispgames/cl-sdl2.git=
- Inside the lisp repl install quick load sdl2, =(ql:quickload "sdl2")=
- Try one of the example
#+begin_src lisp :results none
(ql:quickload :sdl2/examples)
(sdl2-examples:basic-test)
#+end_src
