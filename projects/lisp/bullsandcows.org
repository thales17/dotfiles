#+title: projects/lisp/bullsandcows
<2022-01-11 Tue>

* Bulls and Cows
- This code cracking logic game similar to Mastermind
- The computer picks a random 4 digit number
- The player makes a guess as to what that 4 digit number is
- Each guess is scored by the number of "bulls" and "cows"
- A "bull" means that a digit is in the right position
- A "cow" means that the digit is in the string but not in the right position
- The score doesn't tell you which digit is a "bull" or "cow" only how many digits are each
- For example if the secret is =1234= and the player guesses =4130= the score would be =1B2C=, the =3= being the "bull" and the =4= and =1= being in the code but not in the correct position
- Another requirement of the secret code is that it has no repeating digits
- [[https://en.wikipedia.org/wiki/Bulls_and_Cows][Wikipedia: Bulls and Cows]]

* Project Scope
- This is a series of functions that allow you to play the game bulls and cows inside a common lisp REPL
- You will be able to play the number guessing game or invoke the solver to watch the computer guess the answer

* Implementation
** Setting up the game
- This code defines the game setup function and global variable =*secret-code*=
- The setup function, =bulls-cows-setup=, will generate a list of 4 random integers and store that in =*secret-code*=
- There secret code will not have the digit zero in it
- The algorithm for generating a random code without repeats is as follows:
  - Start with a list of all wanted digits and the length of the secret
  - Check the length of the secret, if =0= return =nil=
  - Pick a random index out of the wanted digits
  - Return the cons of the digit using the random index and a recursive call to the generate code function
  - In the recursive call, slice the randomly picked index from the wanted digits list
  - Additionally reduce the length by 1 in the recursive call
- The setup function returns =t= to not spoil the secret code
#+begin_src lisp
  (defparameter *secret-code* nil)
  (defparameter *code-length* 4)
  (defparameter *code-digits* '(1 2 3 4 5 6 7 8 9))
  (defparameter *code-min* 1234)
  (defparameter *code-max* 9876)

  (defun generate-secret (digits len)
    (unless (<= len 0)
      (let* ((index (random (length digits)))
	     (digit (nth index digits)))
	(cons digit (generate-secret (concatenate 'list
						  (subseq digits 0 index)
						  (subseq digits (1+ index)))
				     (- len 1))))))

  (defun bulls-cows-setup ()
    (setf *secret-code* (generate-secret *code-digits* *code-length*))
    t)
#+end_src

#+RESULTS:
: BULLS-COWS-SETUP
** Scoring a guess
- The player of the game can make a guess on the secret code with the =guess= function
- An example call of the =guess= would look like this =(guess 4130)=
  - In order to convert a number =4130= to the list =(4 1 3 0)= we can convert to string then into a list
  - To convert string numeric characters into numbers again we can use =digit-char-p=
  - We will leave a method that accepts the code as a list as well, this will be good for solvers
- The return will be the score of the guess measured in bulls and cows
- If the secret code is =1234= and you guess =(guess 4130)= the score should be =1B2C=
#+begin_src lisp
  (defun guess-code (code)
    (when (= (length code) *code-length*)
      (let ((bulls 0) (cows 0) (i 0))
	(loop
	 (if (= (nth i code) (nth i *secret-code*))
	     (setf bulls (1+ bulls))
	     (when (member (nth i code) *secret-code*)
	       (setf cows (1+ cows))))
	 (when (= (1+ i) *code-length*)
	   (return))
	 (setf i (1+ i)))

	`(,bulls B ,cows C))))

  (defun guess (num)
    (let ((code (map 'list #'digit-char-p
		     (write-to-string num))))
      (guess-code code)))
#+end_src

#+RESULTS:
: GUESS
** Evaluating scores
- A human player is able to interpret the output of the =guess= function to know if they have won the game or not
- A computer will need a function to easily know if the correct guess has been encountered
- The =equal= function can compare the symbol values with the winning score =(4 B 0 C)=
#+begin_src lisp
  (defun win-p (score)
    (equal score `(,*code-length* B 0 C)))
#+end_src

#+RESULTS:
: WIN-P
** Solvers
- Each of these solvers use the output of the =guess= function to try to automate finding the secret code
- Each solver will count how many times it calls =guess= and return that number along with the secret code
- There are 3024 different possible secret codes (nPr where n = 9 digits and r = 4 length code)
*** Random Guesses
- One of the simplest solvers to implement is to continue to check random guesses to see if they are correct
- This will not be using the clues at all to inform the next guess
- Because of this it is a very inconsistent solution for finding the right answer
- This will use the =generate-secret= method for randomly picking a guess
- While simple to implement this solver it is random how long it will take
- Additionally, it might not find the answer at all
#+begin_src lisp
  (defparameter *max-guesses* 10000)

  (defun run-random-solver ()
    (let ((count 0)
	  (code (generate-secret *code-digits* *code-length*))
	  (solution-found nil))
      (loop
       (cond ((>= count *max-guesses*) (return))
	     ((win-p (guess-code code))
	      (setf solution-found t)
	      (return))
	     (t  (setf count (1+ count))
		 (setf code (generate-secret *code-digits* *code-length*)))))
      (when solution-found
	(list code count)))))
#+end_src

#+RESULTS:
: RUN-RANDOM-SOLVER
*** Brute Force
- This solver will enumerate through all the possible codes and see if it is the right one
- It will not attempt to read the score to understand how close a guess might be
- It is definitely not an efficient method for checking for the code
- It does have the benefit of not being random and always taking the same amount of time to find the answer
- Additionally it should always find an answer
**** TODO Next Permutation
- In order to achieve this we need a function to calculate the next permutation from a given one
- The first permutation should be =1234= the last permutation should be =9876=
- The key to this algorithm is a predicate that verifies if a number is a valid permutation
- If that predicate fails just increment the number and try again
- This removes one instance of the value being checked and then ensures that there is not another instance of it in the list
#+begin_src lisp
  (defun valid-code-p (num)
    (let* ((code (map 'list #'digit-char-p
		      (write-to-string num)))
	   (no-repeats (every #'identity
			      (mapcar #'(lambda (m)
					  (not (member m
						       (remove-if #'(lambda (n) (= n m))
								  code :count 1))))
				      code)))
	   ;; TODO: This should check to make sure the code doesn't have any invalid digits
	   (no-zeros (not (member 0 code))))
      (and no-repeats no-zeros)))
#+end_src

#+RESULTS:
: VALID-CODE-P

- This function finds the next lexical code from a given input
- It continuously increments the number until a valid code is found
#+begin_src lisp
  (defun next-code (num)
    (cond ((valid-code-p (1+ num)) (1+ num))
	  (t (next-code (1+ num)))))

#+end_src

#+RESULTS:
: NEXT-CODE
**** Solver
#+begin_src lisp
  (defun run-brute-force-solver ()
    (let ((code *code-min*)
	  (count 0))
      (loop
	(cond ((win-p (guess code)) (return))
	      ((= code *code-max*) (return))
	      (t (setf code (next-code code))
		 (setf count (1+ count)))))
      `(,code ,count)))

#+end_src
#+RESULTS:
: RUN-BRUTE-FORCE-SOLVER

*** TODO Cows Score Solver
- This solver will use the score to determine if a digit is part of the code or not
- It won't use the bulls portion of the score
- It will sum the total number of digits between bulls and cows to determine if a digit is in the solution or not
- Once the correct digits are determined, this will iterate through all possible permutations until the correct one is found
- The below algorithm will be used to find the secret code:
  - Start with =1234=
  - If the score is 0 then mark all digits as not in the solution
  - If the score is 4 then mark all as being in the solution
  - If the score is greater than 0 and less than 4 begin testing each digit:
    - Iterate through all digits whose included status is unknown
    - Replace the currently tested digit with another unknown digit from the list of all possible digits
    - If the score remains the same:
      - replace with the unknown digit mark both the test digit and unknown digit as not included
      - Replace the test digit with the next and repeat
      - Ensure that the unknown digit is not already in the code being guessed
    - If the score is reduced:
      - Mark the test digit as not included
    - If the score increases:
      - Mark the unknown digit as included and the test digit as not included
  - When the score sum is five but not winning, test each permutation of the current digits until you find a winner
#+begin_src lisp
  ;; (defun run-cows-solver ()
  ;;   (let (())))
#+end_src

#+RESULTS:
: NIL
