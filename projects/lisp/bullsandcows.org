#+title: projects/lisp/bullsandcows
<2022-01-10 Mon>

* Bulls and Cows
- This code cracking logic game similar to Mastermind
- The computer picks a random 4 digit number
- The player makes a guess as to what that 4 digit number is
- Each guess is scored by the number of "bulls" and "cows"
- A "bull" means that a digit is in the right position
- A "cow" means that the digit is in the string but not in the right position
- The score doesn't tell you which digit is a "bull" or "cow" only how many digits are each
- For example if the secret is =1234= and the player guesses =4130= the score would be =1B2C=, the =3= being the "bull" and the =4= and =1= being in the code but not in the correct position
- Another requirement of the secret code is that it has no repeating digits
- [[https://en.wikipedia.org/wiki/Bulls_and_Cows][Wikipedia: Bulls and Cows]]

* Project Scope
- This is a series of functions that allow you to play the game bulls and cows inside a common lisp REPL
- You will be able to play the number guessing game or invoke the solver to watch the computer guess the answer

* Implementation
** Setting up the game
- This code defines the game setup function and global variable =*secret-code*=
- The setup function, =bulls-cows-setup=, will generate a list of 4 random integers and store that in =*secret-code*=
- There secret code will not have the digit zero in it
- The algorithm for generating a random code without repeats is as follows:
  - Start with a list of all wanted digits and the length of the secret
  - Check the length of the secret, if =0= return =nil=
  - Pick a random index out of the wanted digits
  - Return the cons of the digit using the random index and a recursive call to the generate code function
  - In the recursive call, slice the randomly picked index from the wanted digits list
  - Additionally reduce the length by 1 in the recursive call
- The setup function returns =t= to not spoil the secret code
#+begin_src lisp
  (defparameter *secret-code* nil)
  (defparameter *code-length* 4)

  (defun generate-secret (digits len)
    (unless (<= len 0)
      (let* ((index (random (length digits)))
	     (digit (nth index digits)))
	(cons digit (generate-secret (concatenate 'list
						  (subseq digits 0 index)
						  (subseq digits (1+ index)))
				     (- len 1))))))

  (defun bulls-cows-setup ()
    (setf *secret-code* (generate-secret '(1 2 3 4 5 6 7 8 9) *code-length*))
    t)
#+end_src

#+RESULTS:
: BULLS-COWS-SETUP
** Scoring a guess
- The player of the game can make a guess on the secret code with the =guess= function
- An example call of the =guess= would look like this =(guess 4130)=
  - In order to convert a number =4130= to the list =(4 1 3 0)= we can convert to string then into a list
  - To convert string numeric characters into numbers again we can use =digit-char-p=
  - We will leave a method that accepts the code as a list as well, this will be good for solvers
- The return will be the score of the guess measured in bulls and cows
- If the secret code is =1234= and you guess =(guess 4130)= the score should be =1B2C=
#+begin_src lisp
  (defun guess-code (code)
    (when (= (length code) *code-length*)
      (let ((bulls 0) (cows 0))
	(mapcar (lambda (i)
		  (if (= (nth i code) (nth i *secret-code*))
		      (setf bulls (1+ bulls))
		      (when (member (nth i code) *secret-code*)
			(setf cows (1+ cows)))))
		;; Should be a sequence generated from the *code-length*
		'(0 1 2 3))
	`(,bulls B ,cows C))))

  (defun guess (num)
    (let ((code (map 'list #'digit-char-p
		     (write-to-string num))))
      (guess-code code)))
#+end_src

#+RESULTS:
: GUESS
** Evaluating scores
- A human player is able to interpret the output of the =guess= function to know if they have won the game or not
- A computer will need a function to easily know if the correct guess has been encountered
- The =equal= function can compare the symbol values with the winning score =(4 B 0 C)=
#+begin_src lisp
  (defun win-p (score)
    (equal score `(,*code-length* B 0 C)))
#+end_src

#+RESULTS:
: WIN-P
** Solvers
- Each of these solvers use the output of the =guess= function to try to automate finding the secret code
- Each solver will count how many times it calls =guess= and return that number along with the secret code
- There are 3024 different possible secret codes (nPr where n = 9 digits and r = 4 length code)
*** Random Guesses
- One of the simplest solvers to implement is to continue to check random guesses to see if they are correct
- This will not be using the clues at all to inform the next guess
- Because of this it is a very inconsistent solution for finding the right answer
- This will use the =generate-secret= method for randomly picking a guess
- In order to prevent a stack overflow we need to limit the number of max guesses
  - I am using CLISP currently and it appears that it doesn't support tail recursion
- While simple to implement this solver is pretty chaotic
  - It is random how many guesses it will take to find the answer
  - It might not find the answer at all
#+begin_src lisp
  (defparameter *max-guesses* 3000)

  (defun random-solver (g count)
    (cond ((>= count *max-guesses*)
	   nil)
	  ((win-p (guess-code g))
	   (list g count))
	  (t (random-solver (generate-secret '(1 2 3 4 5 6 7 8 9) *code-length*)
			    (1+ count)))))

  (defun run-random-solver ()
    (random-solver (generate-secret '(1 2 3 4 5 6 7 8 9) *code-length*)
		   0))
#+end_src

#+RESULTS:
: RUN-RANDOM-SOLVER
*** Brute Force
- This solver will enumerate through all the possible codes and see if it is the right one
- It will not attempt to read the score to understand how close a guess might be
- It is definitely not an efficient method for checking for the code
- It does have the benefit of not being random and always taking the same amount of time to find the answer
- Additionally it should always find an answer
**** Next Permutation
- In order to achieve this we need a function to calculate the next permutation from a given one
- The first permutation should be =1234= the last permutation should be =9876=
- The key to this algorithm is a predicate that verifies if a number is a valid permutation
- If that predicate fails just increment the number and try again
- This removes one instance of the value being checked and then ensures that there is not another instance of it in the list
#+begin_src lisp
  (defun valid-code-p (num)
    (let* ((code (map 'list #'digit-char-p
		      (write-to-string num)))
	   (no-repeats (every #'identity
			      (mapcar #'(lambda (m)
					  (not (member m
						       (remove-if #'(lambda (n) (= n m))
								  code :count 1))))
				      code)))
	   ;; This should check to make sure the code doesn't have any invalid digits
	   (no-zeros (not (member 0 code))))
      (and no-repeats no-zeros)))
#+end_src

#+RESULTS:
: VALID-CODE-P

- This function finds the next lexical code from a given input
- It continuously increments the number until a valid code is found
#+begin_src lisp
  (defun next-code (num)
    (cond ((valid-code-p (1+ num)) (1+ num))
	  (t (next-code (1+ num)))))

#+end_src

#+RESULTS:
: NEXT-CODE
**** Solver
#+begin_src lisp
  (defun run-brute-force-solver ()
    (let ((code 1234)
	  (count 0))
      (loop
	(cond ((win-p (guess code)) (return))
	      ((= code 9876) (return))
	      (t (setf code (next-code code))
		 (setf count (1+ count)))))
      `(,code ,count)))

#+end_src

#+RESULTS:
: RUN-BRUTE-FORCE-SOLVER
