#+title: notes/programming/lisp
<2022-01-09 Sun>
* Source Files
- Common Lisp source files can have the =.lisp= extension
* Multi-Paradigm
- ANSI Common Lisp is multi paradigm
- It supports functional, generic, object oriented and domain specific programming styles.
* SLIME
- Common Lisp development environment for Emacs
- The official webpage is, https://common-lisp.net/project/slime/
- To use with org babel ensure that =lisp= is enabled in your =org-babel-load-langauges=
- Start slime =M-x slime= before attempting to evaluate a common lisp source block with =C-c C-c=
- You should be able to access variables and functions inside the SLIME REPL that are defined in the source code blocks
- Use =C-c C-d d= to view the documentation for the symbol at point
  - This might show you a link to http://www.ai.mit.edu to get the real documentation
* CLISP
- Easy to use and portable common lisp compiler that runs on most operating systems
- Also provides debugger and interpreter
* SBCL
- Steal Bank Common Lisp
- Considered more heavy duty than CLISP
- Also provides debugger and interpreter
* Common Lisp Syntax
** Literals
*** Char
- You can represent a character literal with a =#= followed by a backward slash and the character
- For example =#\a= is the representation of the character =a=
*** Newline
- =#\newline=
*** Tab
- =#\tab=
*** Space
- =#\space=
*** nil
- nil can be represented with =nil=, ='nil=, =()=, or ='()=
** Symbols
- Symbols in Common Lisp are case insensitive
- It is *common* to only use lowercase when writing common lisp source code
- To make a symbol that is case sensitive surround it with pipe, =|=, characters
  - This also allows you to use punctuation in a symbol name
  - =|Ca$e mATT3rz|= is an example
** Quoting
- Use the single quote ='= to quote a list
- To quasiquote use the backtick =`= and the comma to unquote =,=
- =`(one plus two is ,(+ 1 2))=
- The =#= before the quote is used to indicate the quoted symbol is a function
- Common Lisp is a *LISP-2* rather than a *LISP-1* like Scheme
  - This means it has *2* separate scope for functions and data
  - You can have a function and data with the same symbol name
  - The caveat is you must use the =#= when quoting a function
** Variables
*** Globals
- Use =defparameter= to create global variables
  - The =defparameter= function will mutate the value of a global if it already exists
- It is a common practice to surround global variables with earmuffs (asterisks)
- For example a global named num would look like this =*num*=
- Another option to create globals is =defvar=
  - If the variable already exists =defvar= will not change the existing value
*** Local variables
- Use =let= function to define local variables
*** Mutating
- Use =setf= to change the value of an existing variable
** Functions
*** Globals
- Use =defun= to define a global function
#+begin_src lisp
  (defun function_name (arguments)
    ...body)
#+end_src
*** Local Named Functions
- To define a local function use the =flet= form
- =flet= is very similar to =let= for variables but instead
#+begin_src lisp
  (flet ((function_name (arguments)
	   ...function body))
    ...body)
#+end_src
- If you want to reference other local functions in an =flet= you should use =labels= instead
- You can also =labels= to call a local named function recursively
#+begin_src lisp
  (labels ((function_a (n)
	     (+ n 2))
	   (function_b (n)
	     (function_a (function_a n))))
    (function_b 2))
#+end_src

#+RESULTS:
: 6
*** Argument Limits
- There is a limit on the number of arguments a function can have
- You can check those limits in the Common Lisp REPL with =call-arguments-limit=
** Eval
- You can evaluate a quoted symbol with =eval=
- =(eval '(+ 2 2))= should return =4=
- Like =eval= in JavaScript it can be a huge security risk in your program
* Common Lisp Functions
** Math
*** Incrementing
- You can use =1-= to decrement by 1, =(1- 10)= evaluates to 9
- You can also use =1+= to increment by 1, =(1+ 9)= evaluates to 10
*** Exponent
- Use =expt= to raise a number to an exponent, =(expt 53 53)= raises 53 to the 53rd power
*** Random numbers
- Use the =random= function to generate a random number
- It takes the limit as an argument which can be either an int or a float
- The returned number will be less than the limit
- If it is a float than the random number generated will also be a float
- This has the side effect of changing the internal =random-state=
*** Arithmetic Shift (bitwise shift)
- https://en.wikipedia.org/wiki/Arithmetic_shift
- Use the =ash= function which takes two arguments, the number and the amount of bits to shift left
- To shift right use a negative number
** Strings
*** Concatenate
- Use =concatenate= to join multiple strings together
- Use the symbol ='string= as the first argument to the function
- =(concatenate 'string "abc" "def")= should return ="abcdef"=
*** Converting to and from character lists
- Use =coerce= with either the =list= or =string= type
- =(coerce "ABC" 'list)= should return =(#\A #\B #\C)=
- =(coerce '(#\A #\B #\C) 'string)= should return ="ABC"=
*** Converting symbols to strings
- Use =prin1-to-string= to convert symbols to strings
- =(prin1-to-string 'abc)= should return "ABC"
- The =write-to-string= function also can convert data to strings
** Lists
*** push
- Adds item to the beginning of a list
- The list must be a variable
#+begin_src lisp
  (defparameter *some-list* nil)

  (push 4 *some-list*)
  (push 3 *some-list*)
  (push 2 *some-list*)
  (push 1 *some-list*)
  ,*some-list*
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 |

*** member
- Checks to see if an item is inside a list
- =(member 1 '(1 2 3 4))=
- This will return true when you check if =nil= is in the list
*** find
- Use find to search through a list for the first item that matches
- The search value is the first argument
- The second argument is the list that is being searched
- The keyword parameter passed with =:key= tells find how to determine if the list item matches the search
- =(find 20 '((a 5) (b 20) (c 6) (d 20)) :key #'cadr)= should return =(b 20)=
*** find-if
- Returns the first item in a list that satisifies the predicate
- =(find-if #'oddp '(2 4 5 6))=
- Returns nil if the item is not found
- This will not work when searching for =nil= in a list
*** mapcar
- Use =mapcar= to run a function on each element of a list
- =(mapcar #'(lambda (n) (1+ n)) '(1 2 3))= should return =(2 3 4)=
- You can also run =mapcar= over multiple sequences
- =(mapcar #'(lambda (m n) (list m n)) '(1 2 3) '(a b c))= should return =((1 a) (2 b) (3 c))=
*** apply
- Use =apply= to call a functions once with all the elements of a list as its arguments
*** remove-if-not
- Removes all items from the list that do not satisfy the predicate
- =(remove-if-not #'oddp '(1 2 3 4 5))= should return =(1 3 5)=
*** nth
- Use =nth= to get the value at index n from a list
- =(nth 2 '(7 8 9))= should return =9=
*** use setf and nth to change list item value
- You can use =setf= to mutate a list
- For example if you have a list named =l= with the value =(1 1 1)=
- =(setf (nth 2 l) 4)= should mutate =l= to be =(1 1 4)=
*** subseq
- Use =subseq= to get a sub sequence of a list
- The start index is required and you can optionally add the end index
- The start index is inclusive and the end index is exclusive, =(start end]=
- =(subseq '(9 8 7 6) 1 3)= should return =(8 7)=
*** Swapping list items with =rotatef=
- If you have the list =x= with the value =(1 2 3)=
- You can swap the 1 and with like so =(rotatef (nth 0 x) (nth 2 x))=
- This will mutate the list
*** concatenate
- Use =concatenate= to join multiple lists together
- Use the symbol ='list= as the first argument to the function
- =(concatenate 'list '(1 2 3) '(4 5 6))= should return =(1 2 3 4 5 6)=
*** Slicing an item out of a list
- You can generate a new list with a particular index sliced out using =concatenate= and =subseq=
- If you have the list =d= with the value =(1 2 3 4 5)=
- =(concatenate 'list (subseq d 0 2) (subseq d 3))= should return =(1 2 4 5)=
** Association Lists (alists)
- Use =assoc= to find the value of a key in an alist
#+begin_src lisp
  (assoc 'mykey '((somekey (some-value))
		  (mykey (my-value))
		  (otherkey (other-value))))
#+end_src

#+RESULTS:
| MYKEY | (MY-VALUE) |
- alists can have multiple instances of a key inside them
- When this happens =assoc= will return the first instance
- If you push new keys into the alist you can overwrite the value of a key while preserving the previous value
** Conditionals
*** Shortcut Boolean Evaluation
- When evaluating an =or= or =and= boolean operator lisp will stop when it encounters the first symbol that evaluates to either true or false
- For example when evaluating an =or= the first true that is encountered causes lisp to stop
- When evaluating an =and= the first false encounted causes lisp to stop
- This allows you to build conditionals out of =or= or =and= statements
**** and
#+begin_src lisp
  (defun pred_a ()
    t)

  (defun pred_b ()
    t)

  (defun work ()
    'work-when)

  (when (pred_a)
      (when (pred_b)
	  (work)))
#+end_src

#+RESULTS:
: WORK-WHEN
#+begin_src lisp
  (defun pred_a ()
    t)

  (defun pred_b ()
    t)

  (defun work ()
    'work-and)

  (and (pred_a) (pred_b) (work))
#+end_src

#+RESULTS:
: WORK-AND

**** or
#+begin_src lisp
  (defun pred_a ()
    nil)

  (defun pred_b ()
    nil)

  (defun work ()
    'work-unless)

  (unless (pred_a)
    (unless (pred_b)
      (work)))
#+end_src

#+RESULTS:
: WORK-UNLESS

#+begin_src lisp
  (defun pred_a ()
    nil)

  (defun pred_b ()
    nil)

  (defun work ()
    'work-or)

  (or (pred_a) (pred_b) (work))
#+end_src

#+RESULTS:
: WORK-OR
** Equality
- Use =eq= for comparing symbols
  - =eq= returns true when two symbols point to the same =cons=
  - =eql= will also return true when characters and numbers are used instead of symbols
- Use =equal= for comparing everything else
  - =equal= will tell you if two things are isomorphic (look the same)
  - =equalp= will return true when strings have different capitalization, or numbers are not the same type (floats vs ints)
- The === comparison is meant primarily for numbers
- =string-equal= is specific for strings
- =char-equal= is specific for chars
** I/O
- Use =print= to display a string on stdout
  - This will automatically add a new line at the end of the string
  - =prin1= and =princ= will not add the =newline=
  - =print= will print values as they are stored in Lisp, so strings will have quotes and literals are displayed as such
    - =(print #\newline)= will actually print =#\newline= to stdout
  - Use =princ= to not add the quotation marks and use the characters the literals represent
    - =(princ #\newline)= will just print an empty line
  - The goal of =print= is to output data in a way that it could be re-read back into its internal representation
- Use =read= to read from stdin
  - This function is called with no arguments and returns after the user has typed something and pressed enter
  - You can use this to assign the value into a variable: =(let ((user-input (read))))=
- Both =print= and =read= can handle any Lisp data type, including symbols
- Use =read-line= to read the input as a string only rather than any valid Lisp data
- Use the function =fresh-line= to print a new line: =(fresh-line)=
