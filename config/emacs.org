:NAME: emacs dot org
:AUTHOR: Adam Richardson
#+PROPERTY: header-args :tangle ~/.emacs :results none
* Early Init
Disable package.el since I use straight.el
#+begin_src elisp :tangle ~/.config/emacs/early-init.el :mkdirp yes
  (setq package-enable-at-startup nil)
#+end_src
* Environment
Set various environment variables in emacs
#+begin_src elisp
  (setenv "LD_LIBRARY_PATH"
	  (concat
	   (getenv "HOME")
	   "/.local/lib"))
#+end_src
* Dired Mode
A set of customizations to dired mode to make it a little easier to use
#+begin_src elisp
  (setq dired-dwim-target t)
  (setq dired-recursive-copies (quote always))
  (setq dired-recursive-deletes (quote top))
  (add-hook 'dired-mode-hook
	    (lambda ()
	      (dired-hide-details-mode)))
#+end_src
* Alt Key
This allows the alt key to work as meta
#+begin_src elisp
  (setq x-alt-keysym 'meta)
#+end_src
* Visual line mode in text mode
This ensures that visual line mode is enabled by default for all major modes that derive from text-mode
#+begin_src elisp
  (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+end_src
* Packages
** Setup straight.el
This code is from the straight.el README.md in the github repo [[https://github.com/raxod502/straight.el][straight.el]]
#+begin_src elisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src
*** Upgrading
- =M-x straight-pull-all= or =M-x straight-pull-package=
- The packages will be rebuilt when you restart emacs or you can run =M-x straight-check-all= to rebuild them, (its probably better to restart emacs to clean the old version out)
** Package List
#+begin_src elisp
  (straight-use-package 'magit)
  (straight-use-package 'counsel)
  (straight-use-package 'hydra)
  (straight-use-package 'ivy-hydra)
  (straight-use-package 'ace-window)
  (straight-use-package 'avy)
  (straight-use-package 'markdown-mode)
  (straight-use-package 'geiser)
  (straight-use-package 'geiser-guile)
  (straight-use-package 'bongo)
  (straight-use-package 'projectile)
  (straight-use-package 'counsel-projectile)
  (straight-use-package 'speed-type)
  (straight-use-package 'paredit)
  (straight-use-package 'elfeed)
  (straight-use-package 'password-store)
  (straight-use-package 'password-store-otp)
  (straight-use-package 'lua-mode)
  (straight-use-package 'notmuch)
  (straight-use-package 'yasnippet)
  (straight-use-package 'yasnippet-snippets)
  (straight-use-package 'yafolding)
  (straight-use-package 'coterm)
  (straight-use-package 'disk-usage)
  (straight-use-package 'pulseaudio-control)
  (straight-use-package 'yaml-mode)
  (straight-use-package 'ledger-mode)
#+end_src
* Personal Elisp Files
** shelllike filter
This is a process filter that handles carriage returns and newlines. From this, [[https://stackoverflow.com/questions/19407278/emacs-overwrite-with-carriage-return][using process filter for carriage returns]], stack overflow.
#+name: shelllike-filter
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defun ajr-shelllike-filter (proc string)
    (let* ((buffer (process-buffer proc))
	   (window (get-buffer-window buffer)))
      (with-current-buffer buffer
	(if (not (mark)) (push-mark))
	(exchange-point-and-mark) ;Use the mark to represent the cursor location
	(dolist (char (append string nil))
	  (cond ((char-equal char ?\r)
		 (move-beginning-of-line 1))
		((char-equal char ?\n)
		 (move-end-of-line 1) (newline))
		(t
		 (if (/= (point) (point-max)) ;Overwrite character
		     (delete-char 1))
		 (insert char))))
	(exchange-point-and-mark))
      (if window
	  (with-selected-window window
	    (goto-char (point-max))))))
#+end_src

** elfeed
Info on how to sync elfeed [[http://pragmaticemacs.com/emacs/read-your-rss-feeds-in-emacs-with-elfeed/][here]].
#+name: elfeed
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defun ajr-elfeed ()
    "My command to start and update elfeed"
    (interactive)
    (elfeed-db-load)
    (elfeed)
    (elfeed-search-clear-filter)
    (elfeed-search-update--force)
    (beginning-of-buffer))

  (defun ajr-elfeed-save-db-and-bury ()
    "Wrapper to save the efleed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))
#+end_src

** org capture
#+name: org-capture
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defun ajr-org-basic-capture (key name filename)
    "Generates a basic capture template. It will
  prompt you for the title of the heading and place
  the point in the body of the heading. KEY is the
  character that needs to be pressed in org capture
  to use this template. NAME is the name of the capture
  template. FILENAME is which org file in your org-directory."
    (list key name 'entry
	  (list 'file+headline filename name)
	  "* %^{Title?}\n%?"))
#+end_src

** web search
#+name: web-search
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defun ajr-search-web (term)
    "Prompts the user for a search TERM. Searches
  duckduckgo with eww for the term. Inspired by
  https://gist.github.com/brenns10/69d39f6c46170093f73d"
    (interactive "MSearch Web: ")
    (eww (format "https://html.duckduckgo.com/html/?q=%s"
		 (url-hexify-string term))))
#+end_src

** mail
#+name: mail
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defun ajr-sync-mail ()
    "Starts a process name `syncmail' and sends the output to
  a special mode buffer. This will pop to the buffer as the
  process is running."
    (interactive)
    (with-current-buffer (get-buffer-create "*syncmail*")
      (special-mode)
      (setq buffer-read-only nil)
      (erase-buffer)
      (start-process "syncmail" (current-buffer) "syncmail")
      (setq buffer-read-only t)
      (pop-to-buffer (current-buffer))))
#+end_src

** music
#+name: music
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defcustom ajr-music-dir
    (concat (getenv "HOME")
	    "/music")
    "Directory where your music is kept.")

  (defconst ajr--music-regexp
    "^[^\\.].+$"
    "Only matches files that do not start with a dot")

  (defun ajr--all-albums ()
    "Returns a list of pairs of all available albums `(ARTIST . ALBUM)'"
    (let ((artists (directory-files ajr-music-dir
				    nil
				    ajr--music-regexp)))
      (mapcan (lambda (artist)
		(let ((artist-path (string-join
				    (list ajr-music-dir
					  "/" artist))))
		  (mapcar (lambda (album)
			    `(,artist . ,album))
			  (directory-files artist-path
					   nil
					   ajr--music-regexp))))
	      artists)))

  (defun ajr--ask-album ()
    "Prompts the user to choose an album, returns `(ARTIST . ALBUM)"
    (let* ((albums (ajr--all-albums))
	   (album-display-names
	    (mapcar (lambda (album)
		      (format "%s - %s" (car album) (cdr album)))
		    albums))
	   (albums-alist (mapcar (lambda (n)
				   `(,(nth n album-display-names) .
				     ,(nth n albums)))
				 (number-sequence 0 (- (length albums) 1)))))

      (cdr (assoc (completing-read "Which album? "
			       album-display-names)
	      albums-alist))))

  (defun ajr--album-path (album)
    "Gets the path of an album from `(ARTIST . ALBUM)'"
    (string-join (list ajr-music-dir
		       "/"
		       (car album)
		       "/"
		       (cdr album))))

  (defun ajr-bongo-play-album ()
    "Prompts the user for an album and starts playing it"
    (interactive)
    (let ((album (ajr--ask-album)))
      (with-bongo-playlist-buffer
	(bongo-stop)
	(bongo-erase-buffer)
	(bongo-insert-directory-tree (ajr--album-path album))
	(goto-char (point-min))
	(bongo-play))))
#+end_src

** video
*** Variables
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defcustom ajr-video-dir
    (concat (getenv "HOME")
	    "/videos")
    "Directory where your videos are kept.
  Used the `ajr-video-*' functions.")

  (defcustom ajr-video-program
    "mpv"
    "Program used to play videos.
  This program should accept the path to the video as its argument.")
#+end_src
*** Prompt user for video
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defcustom ajr-video-regexp
    ".+\\.\\(mp4\\|webm\\|mkv\\)$"
    "Only matches files ending in `mp4' or `webm' or `mkv'.")

  (defun ajr--ask-video (is-by-date)
    (let ((videos (directory-files
		   ajr-video-dir
		   nil
		   ajr-video-regexp))
	  (sorted-videos (mapcar 'car (sort
				       (directory-files-and-attributes
					ajr-video-dir
					nil
					ajr-video-regexp)
				       (lambda (x y)
					 (time-less-p
					  (file-attribute-modification-time (cdr y))
					  (file-attribute-modification-time (cdr x))))))))

      (completing-read "Which video? " (if is-by-date
					   sorted-videos
					 videos))))

#+end_src

*** Video playback
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defun ajr-video-play (arg)
    "Prompts the user for a video from `ajr-video-dir'.
  Uses the `ajr-video-program' to play the video. Use C-u
  to sort the videos by date (newest first)."
    (interactive "P")
    (let* ((video (ajr--ask-video arg))
	   (video-buffer (get-buffer-create "*video-player*"))
	   (script-proc-buffer
	    (make-comint-in-buffer "video-player"
				   video-buffer
				   ajr-video-program
				   nil
				   (string-join (list ajr-video-dir
					"/"
					video))))
	   (video-proc (get-buffer-process video-buffer)))
      (with-current-buffer video-buffer
	;; If the buffer was previously in special mode,
	;; need to set read only to false
	(setq buffer-read-only nil))
      (set-process-sentinel video-proc
			    (lambda (proc change)
			      (with-current-buffer (process-buffer proc)
				(special-mode))))))
#+end_src

*** Video dired
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defun ajr-video-dired ()
    "Opens dired buffer to `ajr-video-dir' in other window"
    (interactive)
    (find-file-other-window ajr-video-dir))
#+end_src

*** Video download
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (require 'url-util)
  (defun ajr-video-youtube-dl-at-point ()
    (interactive)
    (let ((yt-url (url-get-url-at-point)))
      (with-current-buffer (generate-new-buffer "*youtube-dl*")
	(special-mode)
	(setq buffer-read-only nil)
	(insert yt-url)
	(newline)
	(cd ajr-video-dir)
	(setq proc (start-process (format "youtube-dl %s"
					  yt-url)
				  (current-buffer)
				  "youtube-dl"
				  "-f"
				  "best[height<=1080]"
				  yt-url))
	(set-process-filter proc 'ajr-shelllike-filter)
	(pop-to-buffer (current-buffer)))))
#+end_src

** mini scroll
Based on [[https://emacsnyc.org/2021/12/06/may-2021-lightning-talks.html][2021 Emacs lightning talk, "Transient Key Maps" - Zachary Kanfer]]
#+begin_src elisp :tangle ~/.emacs.d/ajr.el :mkdirp yes
  (defvar ajr-mini-scroll-amount 5
    "Scroll lines used by ajr-mini-scroll.")

  (defvar ajr-mini-scroll-map
    (let ((m (make-sparse-keymap)))
      (define-key m (kbd "<down>") 'ajr-mini-scroll-up)
      (define-key m (kbd "<up>") 'ajr-mini-scroll-down)
      m))

  (defun ajr-mini-scroll (lines)
    "Scroll by `lines' lines"
    (interactive)
    (scroll-up lines)
    (set-transient-map ajr-mini-scroll-map))

  (defun ajr-mini-scroll-down ()
    "Scroll down"
    (interactive)
    (ajr-mini-scroll (- ajr-mini-scroll-amount)))

  (defun ajr-mini-scroll-up ()
    "Scroll up"
    (interactive)
    (ajr-mini-scroll ajr-mini-scroll-amount))
#+end_src

** ajr.el
 Load the personal elisp files in init file
 #+begin_src elisp
   (load "~/.emacs.d/ajr")
 #+end_src

* Completion
I use ivy for my completion framework
#+begin_src elisp
  (ivy-mode)
#+end_src
* Global Hotkeys
#+begin_src elisp
  (global-set-key (kbd "C-M-s") 'swiper)
  (global-set-key (kbd "C-M-j") 'avy-goto-char)
  (global-set-key (kbd "C-c r") 'ivy-resume)
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  (global-set-key (kbd "<f8>") 'compile)
  (global-set-key (kbd "<f9>") 'whitespace-mode)
  (global-set-key (kbd "<f10>") 'whitespace-cleanup)
  (global-set-key (kbd "<f11>") 'notmuch)
  (global-set-key (kbd "C-<f11>") 'ajr-sync-mail)
  (global-set-key (kbd "<f12>") 'comment-dwim)
  (global-set-key (kbd "<f5>") 'ajr-elfeed)

  ;; password-store
  (global-set-key (kbd "C-<f1>") 'password-store-copy)
  (global-set-key (kbd "C-<f2>") 'password-store-otp-token-copy)

  ;; music
  (define-key global-map (kbd "C-c m") (make-sparse-keymap))
  (global-set-key (kbd "C-c m b") 'bongo-playlist)
  (global-set-key (kbd "C-c m a") 'ajr-bongo-play-album)
  (global-set-key (kbd "C-c m p") 'bongo-pause/resume)
  (global-set-key (kbd "C-c m <right>") 'bongo-next)
  (global-set-key (kbd "C-c m <left>") 'bongo-previous)

  ;; videos
  (define-key global-map (kbd "C-c v") (make-sparse-keymap))
  (global-set-key (kbd "C-c v p") 'ajr-video-play)
  (global-set-key (kbd "C-c v b") 'ajr-video-dired)
  (global-set-key (kbd "C-c v d") 'ajr-video-youtube-dl-at-point)

  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-x w") 'ajr-search-web)
  (global-set-key (kbd "M-o") 'other-window)
  (global-set-key (kbd "C-x o") 'ace-window)
  (global-set-key (kbd "C-<return>") 'yafolding-toggle-element)

  (pulseaudio-control-default-keybindings)

  ;; mini scroll
  (global-set-key (kbd "C-S-v") 'ajr-mini-scroll-up)
  (global-set-key (kbd "M-S-v") 'ajr-mini-scroll-down)
#+end_src

* Paredit
This enables paredit mode for various lisps
#+begin_src elisp
  (autoload 'enable-paredit-mode "paredit"
    "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
#+end_src
* Projectile
Enables projectile mode and sets the project search path and command map
#+begin_src elisp
  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (setq projectile-project-search-path '("~/code"
					 "~/src"))
#+end_src
* Org Mode
Customizations and global keys for org mode
#+begin_src elisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
#+end_src

#+begin_src elisp
  (setq org-capture-templates
	(list (list "t" "TODO")
	      (list "tt" "Basic TODO" 'entry
		    (list 'file "todos.org") "* TODO %?\n"
		    :prepend t)
	      (list "tl" "TODO with link to file" 'entry
		    (list 'file "todos.org")
		    "* TODO %?\n %a"
		    :prepend t)))
#+end_src
* Before Save Hook
#+begin_src elisp
  (add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src
* Bongo
#+begin_src elisp
  (require 'bongo)
#+end_src
* Artist Mode
#+begin_src elisp
  (add-hook 'artist-mode-hook
	    (lambda ()
	      (setq indent-tabs-mode nil)))
#+end_src
* js mode (JavaScript)
#+begin_src elisp
  (add-hook 'js-mode-hook
	    (lambda ()
	      (setq indent-tabs-mode nil)))
#+end_src
* Global Modes
#+begin_src elisp
  (yas-global-mode)
  (yafolding-mode)
  (add-hook 'prog-mode-hook 'linum-mode)
  (add-hook 'prog-mode-hook 'hl-line-mode)
  (coterm-mode)
  (require 'elfeed)
#+end_src
* Customizations
- Customizations should be stored in a separate file =~/.emacs_custom.el=
- This should be last to ensure that the =~/.emacs-custom.el= can do any local overrides that might be needed

#+begin_src elisp
  (setq custom-file "~/.emacs-custom.el")
  (load custom-file)
#+end_src
* Building from source
- clone emacs from [[http://savannah.gnu.org/projects/emacs/][savannah]] =git clone -b master git://git.sv.gnu.org/emacs.git=
- Releases are usually in a branch with the version number, for example =emacs-28=
- Run the =./autogen.sh= to build the configure script
- Use this command to configure with native compilation =./configure --with-native-compilation=
- On Arch Linux you might need to grab =libgccjit= from AUR =mkdir ~/aur && git clone https://aur.archlinux.org/libgccjit.git && cd ~/aur/libgccjit && makepkg -si=
- This will warn you about any missing dependencies, from there you should obtain them for your OS
- Build emacs with =make -j <NUMBER_OF_CPU_CORES+1>=
- Run =make install= with appropriate permissions to install the new version on the system
- Use =M-x emacs-version RET= to see the current version info, including the build date

* Emacs Server Mode
- You can enable the emacs server to start at login with =systemctl --user enable emacs=
- You can connect to the server with =emacsclient -c=
- The =-c= flag creates a new frame
- From the [[https://wiki.archlinux.org/title/Emacs#As_a_systemd_unit][ArchWiki]] when emacs is started from systemd it doesn't source =.bash_profile=
- Another option is the start it in your =.Xprofile= with =emacs --fg-daemon=
- This way would inherit the environment variables

* lsp-mode
- [[https://emacs-lsp.github.io/lsp-mode/page/performance/][lsp-mode performance docs]]
- In addition to native compilation the =--with-json= flag can result in an almost 15x performance increase
- This flag requires =libjansson= to be installed
- Increasing the amount of garbage collection =cons= threshold (=gc-cons-threshold=) to 100Mb =(setq gc-cons-threshold 100000000)=
- Increase the read brocess buffer from 4k to 1mb =(setq read-process-output-max (* 1024 1024)) ;; 1mb=
** lsp-dart
#+begin_src elisp :tangle no
    ;; Dart Stuff
  (straight-use-package 'dart-mode)
  (straight-use-package 'lsp-mode)
  (straight-use-package 'lsp-dart)
  (straight-use-package 'lsp-treemacs)
  (straight-use-package 'flycheck)
  (straight-use-package 'company)
  (straight-use-package 'lsp-ui)
  (straight-use-package 'hover)
  (straight-use-package 'lsp-ivy)

  (add-hook 'dart-mode-hook 'lsp)

  (setq lsp-keymap-prefix "C-c n")

  (defun ajr-lsp-format-on-save-hook ()
    (when (bound-and-true-p lsp-mode)
      (lsp-format-buffer)))

  (add-hook 'before-save-hook 'ajr-lsp-format-on-save-hook)
#+end_src
* elfeed
** Search mode map
#+begin_src elisp
  (eval-after-load "elfeed-search"
    (define-key elfeed-search-mode-map "q" 'ajr-elfeed-save-db-and-bury))
#+end_src
